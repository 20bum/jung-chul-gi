# 11장. 제품 소프트웨어 패키징

모듈별로 생성한 실행 파일들을 묶어 배포용 설치 파일을 만드는 것

* 개발자가 아니라 사용자를 중심으로 진행
* 소스코드는 향후 관리를 고려하여 모듈화하여 패키징한다.
* 사용자가 소프트웨어를 사용하게 될 환경을 이해하여, 다양한 환경에서 소프트웨어를 손쉽게 사용할 수 있도록 일반적인 배포 형태로 패키징한다.
* 사용자의 편의성 및 실행 환경을 우선적으로 고려



#### 고려사항

* 사용자의 시스템 환경 (OS, CPU, 메모리 등) 에 필요한 최소 환경을 정의한다.
* UI는 사용자가 직접 확인할 수 있도록 시각적인 자료와 함께 제공하고 메뉴얼과 일치시켜 패키징한다.
* 하드웨어와 함께 관리될 수 있도록 Managed Service 형태로 제공하는 것이 좋다.
* 편의성을 고려한 안정적인 배포가 중요
* 다양한 요구사항을 반영할 수 있도록 패키징의 변경 및 개선에 대한 관리를 항상 고려한다.



#### 작업순서

패키징 주기는 소프트웨어 개발 기법에 따라 달라지는데, 짧은 개발 주기를 반복하는 애자일 기법인 경우 보통 2~4주 내에서 지정하며, 각 주기가 끝날때마다 패키징을 수행

* 주기별로 패키징한 결과물은 테스트 서버에 배포.
* 최종 패키징한 결과물은 고객이 사용할 수 있도록 온라인 또는 오프라인으로 배포.

![PackagingOrder](img/PackagingOrder.png)



***



## 릴리즈 노트 작성

릴리즈 노트는 개발 과정에서 정리된 릴리즈 정보를 소프트웨어의 최종 사용자인 고객과 고유하기 위한 문서

* 테스트 진행방법에 대한 결과와 소프트웨어 사양에 대한 개발팀의 정확한 준수 여부를 확인할 수 있다.
* 소프트웨어에 포함된 전체 기능, 서비스의 내용, 개선사항 등을 사용자와 공유할 수 있다.
* 소프트웨어의 버전관리나 릴리즈 정보를 체계적으로 관리할 수 있다.
* 소프트웨어 초기 배포시 또는 출시후 개선사항을 적용한 추가 배포 시에 제공한다.
* 초기 배포시 제공되는 릴리즈 노트에서는 소프트웨어에 포함된 기능이나 사용환경에 대한 내용을 확인할 수 있다.
* 소프트웨어 출시후 개선된 작업이 있을 때마다 관련 내용을 릴리즈 노트에 담아 제공한다.



#### 릴리즈 노트 초기 버전 작성 시 고려사항

* 릴리즈 노트는 정확하고 완전한 정보를 기반으로 개발팀에서 직접 현재 시제로 작성해야 한다.
* 신규소스, 빌드 등의 이력이 정확하게 관리되어 변경 또는 개선된 항목에 대한 이력 정보들도 작성되어야 한다.



#### 릴리즈 노트 추가 버전 작성 시 고려사항

소프트웨어의 테스트 과정에서 베타 버전이 출시되거나 긴급한 버그수정, 업그레이드와 같은 자체 기능 향상, 사용자 요청 등의 특수한 상황이 발생하는 경우 릴리즈 노트를 추가로 작성한다.

![ReleaseNoteOrder](img/ReleaseNoteOrder.png)



***



## 디지털 저작권 관리 (DRM)

저작권자가 배포한 디지털 콘텐츠가 저작권자가 의도한 용도로만 사용되도록 디지털 콘텐츠의 생성, 유통, 이용까지의 전 과정에 걸쳐 사용되는 디지털 콘텐츠 관리 및 보호 기술

* 원본 콘텐츠가 아날로그인 경우에는 디지털로 변환한 후 패키저에 의해 DRM 패키징을 수행한다.
* 크기가 작은 경우에는 요청 시점에 실시간으로 패키징을 수행하고, 크기가 큰 경우에는 미리 패키징을 수행한 후 배포한다.
* 패키징을 수행하면 콘텐츠에는 암호화된 저작권자의 전자서명이 포함되고 저작권자가 설정한 라이선스 정보가 클러이랑 하우스(Clearing House) 에 등록된다.
* 사용자가 콘텐츠를 사용하기 위해서는 클리어링 하우스에 등록된 라이선스 정보를 통해 사용자 인증과 콘텐츠 사용 권한 소유 여부를 확인받아야 한다.

* 종량제 방식을 적용한 소프트웨어의 경우 클리어링 하우스를 통해 서비스의 실제 착용량을 측정하여 이용한 만큼의 요금을 부과한다.



#### 디지털 저작권 관리의 흐름도

![DRM_flow](img/DRM_flow.png)

* 클리어링 하우스 (Clearing House) : 저작권에 대한 사용 권한, 라이선스 발급, 사용량에 따른 결제 관리 등일 수행하는 곳
* 콘텐츠 제공자 (Contents Provider) : 콘텐츠를 제공하는 저작권자
* 패키저 (Packager) : 콘텐츠를 메타 데이터와 함께 배포가능한 형태로 묶어 암호화하는 프로그램
* 콘텐츠 분배자 (Contents Distributor) : 암호화된 콘텐츠를 유통하는 곳이나 사람
* 콘텐츠 소비자 (Customer) : 콘텐츠를 구매해서 사용하는 주체
* DRM 컨트롤러 (DRM Controller) : 배포된 콘텐츠의 이용 권한을 통제하는 프로그램
* 보안 컨테이너 (Security Container) : 콘텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치



#### 디지털 저작권 관리의 기술 요소

| 구성 요소                      | 설명                                                       |
| ------------------------------ | ---------------------------------------------------------- |
| 암호화 (Encryption)            | 콘텐츠 및 라이선스를 암호화하고 전자서명을 할 수 있는 기술 |
| 키 관리 (Key Management)       | 콘텐츠를 암호화한 키에 대한 저장 및 분배기술               |
| 암호화 파일 생성 (Packager)    | 콘텐츠를 암호화된 콘텐츠로 생성하기 위한 기술              |
| 식별 기술 (Identification)     | 콘텐츠에 대한 식별 체계 표현 기술                          |
| 저작권 표현 (Right Expression) | 라이선스의 내용 표현 기술                                  |
| 정책 관리 (Policy Management)  | 라이선스 발급 및 사용에 대한 정책 표현 및 관리 기술        |
| 크랙 방지 (Tamper Resistance)  | 크랙에 의한 콘텐츠 사용 방지 기술                          |
| 인증 (Authentification)        | 라이선스 발급 및 사용의 기준이 되는 사용자 인증 기술       |



***



## 소프트웨어 설치 매뉴얼 작성

개발 초기에서부터 적용된 기준이나 사용자가 소프트웨어를 설치하는 과정에 필요한 내용을 기록한 설명서와 안내서이다.

* 설치 매뉴얼은 사용자를 기준으로 작성
* 설치 시작부터 완료할 때까지의 전 과정을 빠짐없이 순서대로 설명
* 설치 과정에서 표시될수 있는 오류 메시지 및 예외 상황에 관한 내용을 별도로 분류하여 설명한다.
* 목차 및 개요, 서문, 기본사항 등이 기본적으로 포함
* 목차에는 전체 설치 과정을 순서대로 요약한 후 관련내용의 시작 페이지를 함께 기술
* 설치 매뉴얼의 주요 특정, 구성과 설치 방법, 순서 등의 내용을 기술



#### 서문

서문에는 문서 이력, 설치 매뉴얼의 주석, 설치 도구의 구성, 설치 환경 체크 항목을 기술한다.

* **문서이력**

* **설치 매뉴얼의 주석**

  > 주의사항, 참고사항 등

* **설치 도구의 구성**

  > + .exe, .dll, .ini, .chm 등의 설치 관련 파일에 대해 설명
  > + 폴더 및 설치 프로그램 실행 파일에 대해 설명
  > + 설치 과정 및 결과가 기록되는 log 폴더에 대해 설명

* **설치 환경 체크 항목**

  > + 사용자 환경 : CPU, Memory, OS 등
  > + 응용 프로그램 : 설치 전 다른 응용 프로그램 종료
  > + 업그레이드 버전 : 업그레이드 이전 버전에 대한 존재 유무 확인
  > + 백업 폴더 확인 : 데이터 저장 폴더를 확인하여 설치 시 폴더를 동기화시킴



#### 기본 사항

소프트웨어와 관련하여 기본적으로 설명되어야 할 항목들

* 소프트웨어 개요

  > + 소프트웨어의 주요 기능 및 UI 설명
  > + UI 및 화면 상의 버튼, 프레임 등을 그림으로 설명

* 설치 관련 파일

  > + 소프트웨어 설치에 필요한 파일 설명
  > + exe, ini, log 등의 파일 설명

* 설치 아이콘 (Installation)

  > + 설치 아이콘 설명

* 프로그램 삭제

  > + 설치된 소프트웨어의 삭제 방법 설명

* 관련 추가 정보

  > + 소프트웨어 이외의 관련 설치 프로그램 정보
  > + 소프트웨어 제작사 등의 추가 정보 기술



#### 설치 매뉴얼 작성 방법

다음의 내용들을 포함한다

* 설치 화면 및 UI

  > 설치 실행과 메인 화면 및 안내창에 대한 내용을 기술한다.

* 설치 이상 메시지 설명

  > 설치 방법이나 설치 환경이 잘못된 경우 표시될 수 있는 메시지에 대해 설명한다.

* 설치 완료 및 결과

  > 설치 완료 화면을 수록하여 설치가 정상적으로 마무리되었음을 사용자에게 최종적으로 알린다.

* FAQ

  > 설치 과정에서 발생할 수 있는 다양한 상황을 FAQ로 정리하여 수록한다.

* 설치 시 점검 사항

  > + 설치 전 사용자의 설치환경에 따라 점검 사항이 무엇인지 설명한다.
  > + 설치에 필요한 사용자 계쩡 및 권한에 대해 확인할수 있도록 설명한다.
  > + 설치 과정 오류가 발생할경우 점검사항에 대해 설명한다.

* Network 환경 및 보안

  > + 문제가 발생하지 않도록 설치전 네트워크 연결상태를 점검하도록 안내
  > + 보안이나 방화벽으로 인한 문제가 발생하지 않도록 관련 내용을 안내

* 고객 지원 방법

  > 설치와 관련하여 기술적인 지원이나 문의할 수 있는 연락처를 안내

* 준수 정보 & 제한 보증

  > + Serial보존, 불법 등록 사용 금지 등에 대한 준수사항 안내
  > + 저작권자 소유자 정보, SW허가권 정보, 통신규격, 개발언어, 연동프로그램, 문서효력, 지적 소유권 정보 등 안내



#### 설치 메뉴얼 작성 순서

![InstallationManual](img/InstallationManual.png)



***



## 소프트웨어 사용자 메뉴얼 작성

사용자가 소프트웨어를 사용하는 과정에서 필요한 내용을 문서로 기록한 설명서와 안내서이다.

* 사용자가 소프트웨어 사용에 필요한 절차, 환경 등의 제반 사항이 모두 포함되도록 작성한다.
* 배포 후 발생될 수 있는 오류에 대한 패치나 기능에 대한 업그레이드를 위해 메뉴얼의 버전을 관리한다.
* 개별적으로 동작이 가능한 컴포넌트 단위로 매뉴얼을 작성한다.
* 사용자 매뉴얼은 컴포넌트 명세서와 컴포넌트 구현 설계서를 토대로 작성한다.
* 목차 및 개요, 서문, 기본 사항 등이 기본적으로 포함되어야 한다.
* 목차에는 매뉴얼 전체 내용을 순서대로 요약한 후 관련 내용의 시작 페이지를 함께 기술한다.
* 개용에는 소프트웨어의 주요 특징, 매뉴얼의 구성과 실행 방법, 사용법, 항목별 점검 기준, 항목별 설정방법 등에 대한 내용을 기술한다.



#### 서문

문서 이력, 사용자 매뉴얼의 주석, 기록보관을 위해 필요한 내용을 기술한다.

* 사용자 매뉴얼의 주석

  > 주의사항, 참고사항을 기술한다.

* 기록 보관 내용

  > + 소프트웨어를 사용하면서 필요한 기술 지원이나 추가 정보를 얻기 위한 소프트웨어 등록정보를 기술한다.
  > + 소프트웨어 등록 시 필요한 정보는 명칭, 모델명, 문서번호, 제품번호, 구입날짜 등



#### 기본 사항

소프트웨어와 관련하여 기본적으로 설명되어야 할 항목

* 소프트웨어 개요

  > + 주요 기능 및 UI 설명
  > + UI 및 화면 상의 버튼, 프레임 등을 그림으로 설명

* 소프트웨어 사용 환경

  > + 소프트웨어 사용을 위한 최소 환경 설명
  > + CPU, 메모리 등의 PC 사양, OS 버전 설명
  > + 최초 구동에 대한 설명
  > + 소프트웨어 사용시 발생할 수 있는 프로그램 충돌이나 개인정보, 보안 등에 관한 주의사항을 설명한다.

* 소프트웨어 관리

  > 소프트웨어의 사용 종료 및 관리 등에 관한 내용 설명

* 모델, 버전별 특징

  > 모델 및 버전별로 UI 및 기능의 차이점을 간략하게 요약한다.

* 기능, 인터페이스의 특징

  > 제품의 기능과 인터페이스의 특징을 간략하게 요약한다.

* 소프트웨어 구동 환경

  > + 개발에 사용한 언어 및 호환 가능한 운영체제에 대해 설명한다.
  > + 설치 후 구동하기까지의 과정을 운영체제별로 설명한다.



#### 사용자 매뉴얼 작성 방법

사용방법을 이해하기 쉽도록 상황별로 누락 없이 캡처하여 순서대로 상세히 설명한다.

다음의 내용을 기술한다.

* 사용자 화면 및 UI

  > 주의사항과 참고사항을 기술

* 주요 기능 분류

  > + 기능이 실행되는 화면을 순서대로 캡처하여 기능에 대한 사용법을 설명
  > + 기능이 구현되는 과정에서 참고할 사항이나 주의할 사항에 대한 메모를 추가

* 응용 프로그램 및 설정

  > + 소프트웨어 구동 시 함께 실행해도 되는 응용 프로그램, 또는 실행하면 안되는 프로그램에 대해 설명한다.
  > + 구동될 때 먼저 실행되어야 할 응용 프로그램이 있다면 설명한다.
  > + 정상적으로 구동되기 위한 설정이나 기본값에 대해 설명

* 장치 연동

  > 소프트웨어가 특정장치에 내장되는 경우 연동되는 장치에 대해 설명한다.

* Network 환경

  > Network에 접속되어 사용되는 소프트웨어인 경우 정상적인 연결을 위한 설정값 등을 설명한다.

* Profile 안내

  > + profile은 소프트웨어의 구동환경을 점검하는 파일로, 사용자가 Profile의 경로를 변경하거나 위치를 이동하지 않도록 안내한다.
  > + Profile과 같이 소프트웨어 구동에 필수적인 파일에 대해 설명한다.

* 고객 지원 방법

  > 사용과 관련된 기술적 지원이나 서비스를 원할 경우 문의할 수 있는 연락처를 안내

* 준수 정보 & 제한 보증

  > + Serial 보존, 불법 등록 사용 금지 등에 대한 준수사항을 안내
  > + 저작권자 소유권 정보, SW 허가권 정보, 통신규격, 개발언어, 연동 프로그램, 문서효력, 지적 소유권 정보등 관련 정보 안내



#### 사용자 매뉴얼 작성 순서

![CustomerManual](img/CustomerManual.png)



***



## 소프트웨어 버전 등록



#### 소프트웨어 패키징의 형상 관리

형상관리 (SCM; Software Configuration Management) 는 소프트웨어 개발 과정에서 변경 사항을 관리하기 위해 개발된 일련의 활동

* 변경의 원인을 알아내고 제어하며, 적절히 변경되고 있는지 확인하여 해당 담당자에게 통보한다.
* 소프트웨어 개발의 전 단계에 적용되는 활동이며, 유지보수 단계에서도 수행된다.
* 소프트웨어 전체 비용을 줄이고, 개발 과정의 여러 방해 요인이 최소화되도록 보증하는 것을 목적으로 한다.



#### 형상관리의 중요성

* 지속적으로 소프트웨어의 변경사항을 체계적으로 추적하고 통제할 수 있다.
* 제품 소프트웨어에 대한 무절제한 변경을 방지할 수 있다.
* 제품 소프트웨어에서 발견된 버그나 수정 사항을 추적할 수 있다.
* 소프트웨어는 가시성이 결핍되므로 진행 정도를 확인하기 위한 기준으로 사용될 수 있다.



#### 형상 관리 기능

품질 보증을 위한 중요한 요소로서 다음과 같은 기능을 수행

* 형상식별

  > 형상 관리 대상에 이름과 관리 번호를 부여하고, 계층(Tree) 구조로 구분하여 수정 및 추적이 용이하도록 하는 작업

* 버전 제어

  > 업그레이드나 유지 보수 과정에서 생성된 다른 버전의 형상 항목을 관리하고, 이를위해 절차와 도구를 결합시키는 작업

* 형상 통제 (변경 관리)

  > 식별된 형상 항목에 대한 변경 요구를 검토하여 현재의 기준선이 잘 반영될 수 있도록 조정하는 작업

* 형상 감사

  > 기준선의 무결성을 평가하기 위해 확인, 검증, 검열 과정을 통해 공식적으로 승인하는 작업

* 형상 기록 (상태 보고)

  > 형상의 식별,  통제, 감사 작업의 결과를 기록∙관리 하고 보고서를 작성하는 작업



#### 소프트웨어의 버전등록 관련 주요용어

| 항목                 | 설명                                                         |
| -------------------- | ------------------------------------------------------------ |
| 저장소 (Repository)  | 최신 버전의 파일들과 변경 내역에 대한 정보들이 저장된 곳     |
| 가져오기 (Import)    | 관리되지않은 아무것도 없는 저장소에 처음으로 파일을 복사한다. |
| 체크아웃 (Check-Out) | - 프로그램을 수정하기 위해 저장소에서 파일을 받아온다<br />- 소스파일과 함께 버전 관리를 위한 파일들도 받아온다. |
| 체크인 (Check-In)    | 체크아웃 한 파일의 수정을 완료한 후 저장소의 파일을 새로운 버전으로 갱신한다. |
| 커밋 (Commit)        | 체크인을 수행할 때 이전에 갱신된 내용이 있는 경우에는 충돌을 알리고<br /> diff 도구를 이용해 수정한 후 갱신을 완료한다. |
| 동기화 (Update)      | 저장소에 있는 최신 버전으로 자신의 작업 공간을 동기화한다.   |



#### 소프트웨어 버전 등록 과정

![SCM_flow](img/SCM_flow.png)



***



## 소프트웨어 버전 관리 도구

#### 공유 폴더 방식

버전 관리 자료가 로컬 컴퓨터의 공유 폴더에 저장되어 관리되는 방식으로, 다음의 특징들이 있다.

* 개발이 완료된 파일을 약속된 공유 폴더에 매일 복사한다.
* 담당자느 공유 폴더의 파일을 자기 PC로 복사한 후 컴파일 하여 이상 유무를 확인한다.
* 이상 유무 확인 과정에서 파일의 오류가 확인되면, 해당 파일을 등록한 개발자에게 수정을 의뢰한다.
* 파일에 이상이 없다면 다음날 각 개발자들이 동작 여부를 다시 확인한다.
* 파일을 잘못 복사하거나 다른 위치로 복사하는 것에 대비하기 위해 파일의 변경 사항을 데이터베이스에 기록하여 관리한다.
* SCCS, RCS, PVCS, QVCS 등 이 있다.



#### 클라이언트 / 서버 방식

버전 관리 자료가 중앙 시스템(서버)에 저장되어 관리되는 방식

* 서버의 자료를 개발자별로 자신의 PC (클라이언트) 로 복사하여 작업한 후 변경된 내용을 서버에 반영
* 모든 버전관리는 서버에서 수행
* 하나의 파일을 서로 다른 개발자가 작업할 경우 경고 메시지를 출력
* 서버에 문제가 생기면, 서버 복구 전까지 작업은 중단된다.
* CVS, SVN (Subversion), CVSNT, Clear Case, CMVC, Perforce 등이 있다.



#### 분산 저장소 방식

버전관리 자료가 하나의 원격 저장소와 분산된 개발자 PC의 로컬 저장소에 함께 저장되어 관리되는 방식

* 개발자별로 원격 저장소의 자료를 자신의 로컬저장소로 복사하여 작업한후 변경된 내용을 로컬 저장소에서 우선 반영(버전관리) 한 다음 이를 원격 저장소에 반영
* 로컬 저장소에서 버전관리가 가능하므로 원격저장소에 문제가 생겨도 로컬 저장소의 자료를 이용하여 작업할 수 있다.
* Git, GNU arch, DCVS, Bazaar, Mercurial, TeamWare, Bitkeeper, Plastic SCM 등



#### Subversion (서브버전, SVN)

CVS를 개선한 것으로, 아파치 소프트웨어 재단에서 2000년에 발표하였다.

* 클라이언트/서버 구조로, 서버(저장소) 에는 최신 버전의 파일들과 변경 내역이 관리된다.
* 서버의 자료를 클라이언트로 복사해와 작업한 후 변경내용을 서버에 반영(Commit) 한다.
* 모든 개발 작업은 trunk 디렉터리에서 수행되며, 추가 작업은 branches 디렉터리 안에 별도의 디렉터리를 만들어 작업을 완료한 후 trunk 디렉터리와 병합(Merge)한다.
* 커밋(Commit) 할때 마다 리비전(Revision)이 1씩 증가한다.
* 클라이언트는 대부분의 운영체제에서 사용되지만, 서버는 주로 유닉스를 사용한다.
* 소스가 오픈되어 있어 무료로 사용할 수 있다.
* CVS의 단점이었던 파일이나 디렉터리의 이름 변경, 이동 등이 가능하다

###### 주요 명령어

| 명령어      | 의미                                                         |
| ----------- | ------------------------------------------------------------ |
| add         | - 새로운 파일이나 디렉터리를 버전 관리 대상으로 등록<br />- add로 등록되지 않은 대상은 commit이 적용되지 않는다. |
| commit      | 버전관리 대상으로 등록된 클라이언트의 소스파일을 서버의 소스파일에 적용한다. |
| update      | - 서버의 최신 commit 이력을 클라이언트의 소스 파일에 적용<br />- commit전 매번 update를 수행하여 클라이언트에 적용되지 않은 서버의 변동 내역을 클라이언트 적용 |
| checkout    | 버전 관리 정보와 소스 파일을 서버에서 클라이언트로 받아온다  |
| lock/unlock | 서버의 소스 파일이나 디렉터리를 잠그거나 해제한다            |
| import      | 아무것도 없는 저장소에 맨처음 소스파일을 저장하는 명령       |
| export      | 버전관리에 대한 정보를 제외한 순수한 소스 파일만을 서버에서 받아온다. |
| info        | 지정한 파일에 대한 위치나 마지막 수정 일자 등에 대한 정보 표시 |
| diff        | 지정된 파일이나 경로에 대해 이전 리비전과의 차이를 표시      |
| merge       | 다른 디렉터리에서 작업된 버전 관리 내역을 기본 개발 작업과 병합한다. |



#### Git (깃)

* 분산 버전 관리 시스템으로 2개의 저장소, 지역(로컬) 저장소와 원격 저장소가 존재
* 지역 저장소는 개발자들이 실제 개발을 진행하는 장소로, 버전관리가 수행된다.
* 원격 저장소는 여러 사람들이 협업을 위해 버전을 공동 관리하는 곳으로, 자신의 버전 관리 내역을 반영하거나 다른 개발자의 변경 내역을 가져올때 사용한다.
* 버전 관리가 지역저장소에서 진행되므로 버전관리가 신속하게 처리되고 원격 저장소나 네트워크에 문제가 있어도 작업이 가능하다.
* 브랜치를 이용하면 기본 버전 관리 틀에 영향을 주지 않으면서 다양한 형태의 기능 테스팅이 가능하다.
* 파일의 변화를 스냅샷으로 저장하는데, 스냅샷은 이전 스냅샷의 포인터를 가지므로 버전의 흐름을 파악할 수 있다.

###### 주요 명령어

| 명령어     | 의미                                                         |
| ---------- | ------------------------------------------------------------ |
| add        | - 저장내역을 지역 저장소에 저장하기 위해 스테이징 영역에 추가<br />- '--all' 옵션으로 작업 디렉터리의 모든 파일을 스테이징 영역에 추가할 수 있다. |
| commit     | - 작업 내역을 지역 저장소에 저장한다.<br />- '-m'옵션으로 메시지를 부여할 수 있다. |
| branch     | - 새로운 브랜치를 생성한다<br />- 최초로 commit을 하면 마스터 브랜치가 생성된다<br />- commit 할때마다 해당 브랜치는 가장 최근의 commit 내용을 가리킨다.<br />- '--d' 옵션으로 브랜치를 삭제할 수 있다 |
| checkout   | - 지정한 브랜치로 이동한다<br />- 현재 작업중인 브랜치는 HEAD 포인터가 가리키는데,<br /> checkout 명령을 통해 HEAD 포인터를 지정 브랜치로 이동시킨다. |
| merge      | 지정한 브랜치의 변경내역을 현재 포인터가 가리키는 브랜치에 반영함으로 두 브랜치를 병합한다. |
| init       | 지역 저장소를 생성한다.                                      |
| remote add | 원격 저장소에 연결한다.                                      |
| push       | 로컬 저장소의 변경 내역을 원격 저장소에 반영한다.            |
| fetch      | 원격 저장소의 변경 이력만을 지역 저장소로 가져와 반영한다.   |
| clone      | 원격 저장소의 전체 내용을 지역 저장소로 복제한다.            |
| fork       | 지정한 원격 저장소의 내용을 자신의 원격 저장소로 복제한다.   |



***



## 빌드 자동화 도구

빌드란 소스 코드 파일들을 컴파일한 후 여러 개의 모듈을 묶어 실행 파일로 만드는 과정이며, 이런 빌드를 포함하여 테스트 및 배포를 자동화하는 도구를 빌드 자동화 도구라고 한다.

* Ant, Make, Maven, Gradel, Jenkins 등이 있다.



#### Jenkins

Java 기반의 오픈 소스 형태로, 가장 많이 사용되는 빌드 자동화 도구이다.

* 서블릿 컨테이너에서 실행되는 서버기반 도구이다.
* SVN, Git 등 대부분의 형상 관리 도구와 연동이 가능
* 친숙한 Web GUI 제공으로 사용이 쉽다.
* 여러대의 컴퓨터를 이용한 분산 빌드나 테스트가 가능.



#### Gradle

Groovy를 기반으로 한 오픈 소스 형태의 자동화 도구, 안드로이드 앱 개발 환경에서 사용된다.

* 안드로이드 뿐만 아니라 플러그인을 설정하면, Java, C/C++, Python 등의 언어도 빌드가 가능하다.
* Groovy를 사용해서 만든 DSL(Domain Specific Language)을 스크립트 언어로 사용한다.
* Gradle은 실행할 처리 명령들을 모아 Task로 만든후 테스크 단위로 실행한다.
* 이전 사용했던 태스크를 재사용하거나 다른 시스템의 태스크를 공유할 수 있는 빌드 캐시 기능을 지원하므로 빌드의 속도를 향상시킬 수 있다.

